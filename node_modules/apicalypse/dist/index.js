import axios from "axios";
import Queue from "better-queue";
import MemoryStore from "better-queue-memory";
import Builder from "./builder.js";
const axiosInstance = axios.create();
class Apicalypse extends Builder {
    constructor(opts) {
        super();
        this.initialApicalypse = opts.apicalypse || "";
        this.apicalypse = this.initialApicalypse;
        this.config = {
            queryMethod: "body",
            ...opts,
        };
    }
    constructOptions(url) {
        if (!this.isMulti) {
            this.build();
            if (!this.apicalypse) {
                this.apicalypse = this.initialApicalypse;
            }
        }
        const options = {
            url: url || this.config.url || "",
        };
        switch (this.config.queryMethod) {
            case "url": {
                options.params = {
                    apicalypse: encodeURIComponent(this.apicalypse),
                };
                break;
            }
            case "body": {
                options.data = this.config.data || this.apicalypse;
                break;
            }
        }
        this.resetRequest();
        return { ...this.config, ...options };
    }
    async request(url) {
        const instance = this.config.axiosInstance || axiosInstance;
        const response = await instance(this.constructOptions(url));
        return response;
    }
    resetRequest() {
        this.resetQueryFields();
        this.apicalypse = this.initialApicalypse;
        this.config.data = this.apicalypse || false;
    }
    cleanLimitOffset() {
        var _a, _b;
        const limitStr = (_a = this.queryFields.limit) === null || _a === void 0 ? void 0 : _a.split(" ")[1];
        const offsetStr = (_b = this.queryFields.offset) === null || _b === void 0 ? void 0 : _b.split(" ")[1];
        const limit = limitStr ? parseInt(limitStr) : 50;
        const offset = offsetStr ? parseInt(offsetStr) : 0;
        delete this.queryFields.limit;
        delete this.queryFields.offset;
        return { limit, offset };
    }
    requestAll(url, opts = {}) {
        const { concurrency, delay } = opts;
        return new Promise((resolve) => {
            let allData = [];
            const { limit, offset } = this.cleanLimitOffset();
            const q = new Queue(async (page, cb) => {
                this.cleanLimitOffset();
                this.limit(limit);
                this.offset(offset + page * limit);
                const response = await this.request(url);
                allData = allData.concat(response.data);
                if (response.data.length >= limit) {
                    q.push(page + 1);
                }
                setTimeout(() => {
                    cb(null);
                }, delay || 0);
            }, {
                concurrent: concurrency || 1,
                store: new MemoryStore(),
            });
            q.on("drain", () => {
                resolve(allData);
            });
            const initialPage = Math.floor(offset ? offset / limit : 0);
            q.push(initialPage);
        });
    }
}
export default function (apicalypse, opts = {}) {
    if (typeof apicalypse === "string") {
        opts.apicalypse = apicalypse;
    }
    else if (apicalypse) {
        opts = apicalypse;
    }
    return new Apicalypse(opts);
}
